---
title: 内核驱动开发7 私有句柄表
published: 2024-11-23T22:06:26+08:00
summary: "私有句柄表"
tags: [内核,私有句柄表]
categories: '内核驱动'
draft: false 
lang: ''
---

## 句柄答疑(CHATGPT)


在 Windows 操作系统中，**句柄 (HANDLE)** 是一个非常基础但又至关重要的概念。句柄是用于标识和访问系统对象的抽象表示，具体来说，它是内核对象（例如文件、进程、线程、信号量等）的一个引用。句柄的目的是在用户空间中提供一种安全、简单的方法来与操作系统中的资源进行交互。

### 什么是句柄 (HANDLE)?
句柄可以理解为一个**引用或指针**，但与直接使用内存地址不同，句柄是系统分配的一个标识符，它抽象化了对底层资源的访问。Windows 会为应用程序分配一个整数或指针值作为句柄，用户态程序通过这个句柄值来访问底层内核对象，而不需要直接操作内核对象本身。

### 句柄的作用和存在的意义
1. **封装复杂性**：句柄屏蔽了内核对象的内部实现细节。应用程序通过句柄与内核对象交互，而不需要关心这些对象的内部结构如何运作。这种封装简化了系统资源的管理。
   
2. **安全性**：句柄可以确保用户态程序不会直接访问和修改内核空间的数据。这是一个安全性边界，因为直接访问内核空间可能导致系统崩溃或安全问题。通过句柄，系统可以控制程序的访问权限和操作类型。

3. **资源管理**：Windows 通过句柄来管理系统资源。每个句柄都与一个特定的内核对象相关联，例如文件、进程、线程、事件等。当应用程序使用完这些资源后，必须释放句柄，否则可能会导致资源泄露。

### 句柄的内部运作机制
- **句柄表 (Handle Table)**：
   每个进程都有自己的句柄表，它是一个关联数组，保存了进程可以访问的所有句柄。表中每个条目都存储了一个句柄与其对应内核对象的映射关系。当应用程序请求访问某个对象时，系统会在句柄表中查找对应的内核对象。

- **句柄的类型**：
   Windows 中有很多种内核对象，每种对象都可以通过句柄来引用。例如：
   - **文件句柄**：引用打开的文件。
   - **进程句柄**：引用正在运行的进程。
   - **线程句柄**：引用某个线程。
   - **事件句柄**：引用同步对象，比如事件。
   - **信号量句柄**：用于控制对共享资源的访问。
   
   每种对象类型在内核中有不同的结构体表示，但对用户来说，只需要知道句柄对应的资源对象即可。

### 句柄的存储位置
句柄是保存在用户进程的句柄表中的。每个进程在创建时，Windows 会为该进程分配一个句柄表。句柄表保存在内核态，应用程序无法直接访问它，但可以通过句柄间接访问其中的资源。当一个句柄被创建时，内核对象会在进程的句柄表中生成一个条目，并且返回给应用程序一个整数值作为句柄。

### 句柄与内核对象的关系
1. **句柄并不直接指向内核对象**，它只是在内核中创建了一个到对象的引用。这种间接引用有助于确保应用程序无法直接访问和修改内核对象。
   
2. **句柄可以拥有不同的权限**，例如只读权限、写权限、全访问权限等。通过这种权限机制，句柄可以用来限制进程对资源的操作。

### 句柄的生命周期
句柄的生命周期通常由以下几个阶段构成：

1. **创建句柄**：当一个进程或线程请求访问某个资源（例如打开文件、创建进程或线程）时，操作系统会为该进程分配一个句柄。句柄的创建通常通过调用系统 API 实现，例如 `CreateFile` 会返回一个文件句柄。
   
2. **使用句柄**：一旦获得了句柄，应用程序可以通过该句柄来操作相关的资源。例如，通过文件句柄读取或写入文件，通过进程句柄终止某个进程。

3. **关闭句柄**：当进程不再需要某个资源时，应该调用 `CloseHandle` 函数来关闭句柄。这会告诉操作系统可以释放资源，防止资源泄漏。如果没有及时关闭句柄，资源可能会一直占用系统内存或其他资源，导致系统性能下降甚至崩溃。

### 句柄泄露问题
**句柄泄露** 是指进程没有在使用完资源后释放句柄，从而导致资源无法被回收。例如，如果打开文件后没有关闭文件句柄，该文件将保持占用状态，其他进程可能无法访问，内存也可能因为泄露逐渐增多，最终导致系统资源耗尽。

### 句柄的一些常用操作
- **创建句柄**：例如 `CreateFile` 创建一个文件句柄。
  
- **获取现有对象的句柄**：例如通过 `OpenProcess` 获取进程句柄，或者通过 `FindWindow` 获取窗口句柄。

- **操作对象**：一旦获取了对象的句柄，就可以调用与该句柄相关的函数来操作对象。例如，使用 `ReadFile` 通过文件句柄读取文件。

- **关闭句柄**：使用 `CloseHandle` 来关闭句柄，释放资源。

### 常见句柄类型
1. **文件句柄**：使用文件系统资源时，Windows 返回一个文件句柄，表示已经打开的文件或设备。常用函数如 `CreateFile` 和 `CloseHandle`。
   
2. **进程句柄和线程句柄**：在控制和操作进程和线程时，Windows 返回这些句柄。例如，`OpenProcess` 用来获取进程句柄。

3. **同步对象句柄**：包括事件、信号量、互斥体等。它们用于线程同步和进程间通信。

### 总结
- **句柄 (HANDLE)** 是一种抽象，用来标识和访问内核对象，如文件、进程、线程等。
- 句柄为用户态程序提供了安全的接口来与内核对象交互。
- 每个进程都有自己的句柄表，用于存储和管理该进程可以访问的所有句柄。
- 使用句柄时，程序员必须确保在使用完资源后关闭句柄，以避免资源泄露。

### 句柄的意义与问题的解决：
句柄机制的存在解决了**安全性、资源管理和系统复杂性**等问题：
- **安全性**：用户态程序无法直接操作内核对象，防止恶意操作或意外错误影响系统稳定性。
- **简化编程**：程序员无需关心内核对象的内部实现，只需要通过句柄进行高层次的操作。
- **资源管理**：通过句柄可以有效跟踪和管理系统资源的使用，防止资源泄漏。


## 判断是进程句柄表还是线程句柄表(全局表中)

**原理**
需要找到对象头,即EPROCESS-0x30(OBJECT_HEADER,0x30这个值会随着不同系统改变),通过对象头判断对象属于什么类型,判断出句柄指向的是什么类型,得到句柄是进程句柄还是线程句柄

**背景：**
`EPROCESS` `是进程对象，ETHREAD` 是线程对象。
每个内核对象都有一个对应的对象头（OBJECT_HEADER），该对象头保存了一些有关对象的信息，包括它的类型索引（TypeIndex）。
OBJECT_HEADER 中的 TypeIndex 字段需要解密，通过解密后的 TypeIndex 可以找到对象的类型，该类型在一个名为 ObTypeIndexTable 的数组中，该数组的元素指向 `_OBJECT_TYPE` 结构，_OBJECT_TYPE 结构包含对象类型的名称（如 "`Process`" 或 "`Thread`"）。


**补全步骤**

1. **找到 `EPROCESS` 的对象头**：

    通过 EPROCESS 对象的地址，可以定位其对象头。
    EPROCESS 对象的对象头位于 EPROCESS 对象起始地址减去 0x30 的位置。因此，对象头地址 = EPROCESS 地址 - 0x30。
2. **定位 `OBJECT_HEADER` 结构中的 `TypeIndex` 字段：**

    `TypeIndex` 是 `OBJECT_HEADER` 结构的一个字段，表示对象类型的加密索引（即类型索引的密文）。
    `TypeIndex` 位于对象头中的某个偏移处，通常在 `OBJECT_HEADER` 的后部。
3. **进行解密操作**：

    - 为了获取真正的 `TypeIndex`，你需要解密它。解密需要用到一个名为 `ObHeaderCookie` 的全局变量，它通常用于增加安全性，防止直接攻击对象头。
    - 解密的公式为：
    ```
    index = (UCHAR)(ObHeaderCookie) ^ (pObjectHeader->TypeIndex) ^ (UCHAR)(pEPROCESS >> 8)
    ```


```windbg
dt _EPROCESS 0x123454625-0x30
 

 其中typeindex是一个未解密数组的索引(从零开始),数组是ObtypeIndexTable,每一个表项的是一个指针,指向的是一个结构叫_OBJECT_TYPE


 为了解密typeindex,需要进行如下运算

把0x123454625右移8位,取最低位1个字节E0

db ObHeaderCookie 取他的第一位假设是da,假设typeindex位是0x3d

da^0x3d^E0

得到结果是7,那么这个7就是ObtypeIndexTable数组中的索引,把对应的地址用_OBJECT_TYPE解读

index =(UCHAR)(obHeaderCookie) ^ (pOBjectHeader->TypeIndex) ^ (UCHAR)(pOBjectHeader >>
8)

_OBJECT_TYPE里面的Name会显示是进程还是线程

```



三种降权的方法：改CallBackList、改PSProcessType>>SupportsObjectCallbacks、改ReTainAccess
